<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>ZeroEQ: HTTP Server for generic REST interfaces</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ZeroEQ
   &#160;<span id="projectnumber">0.8.0</span>
   </div>
   <div id="projectbrief">ZeroEQ - Zero Event Queue</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('httpserverrest.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">HTTP Server for generic REST interfaces </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This document describes a proposed extension to the current <a href="http::Server">http::Server</a> to make it usable as a general-purpose REST interface.</p>
<h2>Requirements</h2>
<ul>
<li>Support all standard http verbs: GET, POST, PUT, PATCH, DELETE</li>
<li>Support custom response payload for all action verbs (not just for GET)</li>
<li>Allow specifying the MIME type of the response to serve any type of content</li>
<li>Allow specifying extra HTTP header fields in response to certain requests</li>
<li>Allow asynchronous processing of requests (not blocking the main thread)</li>
<li>Single endpoint for collections (e.g. windows/, files/, neurons/, etc. )</li>
<li>Allow filtering operations on collections (windows/selected, files?limit=10)</li>
</ul>
<h2>Dependency Changes</h2>
<p>None, cppnetlib 0.13 already offers the required functionality.</p>
<h1>Proposition #1</h1>
<h2>API</h2>
<p>To fullfill the requirements with minimal API changes, we propose a generic interface as follows: </p><pre class="fragment">namespace zeroeq
{
namespace http
{
enum class Verb { GET, POST, PUT, PATCH, DELETE };

// copied from HTTPServer::connection::status_t
enum Code { OK = 200, NOT_FOUND = 404, ... };

// some commonly used headers, see:
// https://en.wikipedia.org/wiki/List_of_HTTP_header_fields
enum class Header{ LOCATION, RETRY_AFTER, ... };

struct Response
{
    Code code = Code::OK;
    std::string contentType;
    std::string payload;
    std::map&lt;Header, std::string&gt; headers;
};

/** HTTP REST callback with payload, returning a Response future. */
using RESTFunc = std::function&lt;std::future&lt;Response&gt;(const std::string&amp;)&gt;;

/** HTTP REST callback with path + payload, returning a Response future. */
using RESTPathFunc = std::function&lt;std::future&lt;Response&gt;(const std::string&amp;,
                                                         const std::string&amp;)&gt;;

class Server
{
public:
    /** ... */

    /** Handle a single action on a given endpoint. */
    void handle(Verb action, const std::string&amp; endpoint, RESTFunc func);

    /** Handle all urls starting with the given endpoint. */
    void handlePath(Verb action, const std::string&amp; endpoint,
                    RESTPathFunc func);

    /** ... */
}
}
}
</pre><h2>Examples</h2>
<p>The following example shows how the API could be use to expose a collection of windows. For illustration purposes, both handle() and handlePath() are used. Note how the asychronous API is used to process the most time consuming requests without blocking the main thread. </p><pre class="fragment">using namespace zeroeq;
http::Server server{ /** ... */ };

void makeThumbnail(const std::string&amp; windowId)
{
    auto response = http::Response{};
    response.contentType = "image/jpeg";
    response.payload = doTheHeavyWork(windowId);
    return response;
}

// simplified window collection for the example
std::set&lt;std::string&gt; windows{"1234", "567"};

// Register an individual endpoint for each thumbnail. Note that this is
// tedious to manage as the list of windows evolves. It could be more
// efficiently served by a generic function:
// server.handlePath(http::Verb::GET, "api/windows", getWindowInfo );
for (const auto&amp; windowId : windows)
{
    const auto makeThumbnailAsync = [windowId](const std::string&amp;)
    {
        return std::async(std::launch::async, makeThumbnail, windowId);
    };
    server.handle(http::Verb::GET, "api/windows/"+windowId+"/thumbnail",
                  makeThumbnailAsync);
}

// Here we use a generic endpoint for all window close operations. "path"
// provides the url part after the endpoint: "api/windows/567" -&gt; "567"
const auto closeWindow = [&amp;](const std::string&amp; path, const std::string&amp;)
{
    if (!windows.count(path))
        return make_ready_future(http::Response{http::Code::NOT_FOUND});

    server.remove("api/windows/"+path+"/thumbnail");
    windows.erase(path);
    return make_ready_future(http::Response{http::Code::OK});
};
server.handlePath(http::Verb::DELETE, "api/windows", closeWindow);

// This function uses POST to open a new window and return its location.
const auto openWindow = [&amp;](const std::string&amp; request)
{
    if (!windows.insert(request))
        return make_ready_future(http::Response{http::Code::NO_CONTENT});

    auto response = http::Response();
    response.code = http::Code::CREATED;
    response.headers[http::Header::LOCATION] = "api/windows/"+request;
    return make_ready_future(std::move(response));
};
server.handle(http::Verb::POST, "api/windows", openWindow);
</pre><h2>Implementation</h2>
<p>In requestHandler.h, the struct HTTPRequest needs to be changed from: </p><pre class="fragment">// output from zeroeq::http::Server
HTTPServer::connection::status_t status;
std::string reply;
</pre><p>to </p><pre class="fragment">// output from zeroeq::http::Server
std::future&lt;Response&gt; response;
</pre><p>In requestHandler.cpp, the ConnectionHandler must wait on response.get();</p>
<p>In server.cpp, all existing handle*() functions must be adapted to wrap the response data as ready futures. Additional maps must be added for the POST, PATCH and DELETE actions.</p>
<h1>Proposition #2</h1>
<p>This proposition makes use of cppnetlib's internal thread pool to execute the asynchronous functions, removing some complexity from user code.</p>
<h2>API</h2>
<p>Same enums and Response struct as in proposition #1: </p><pre class="fragment">namespace zeroeq
{
namespace http
{

/** HTTP REST callback with payload, returning an http Response. */
using RESTFunc = std::function&lt;Response(const std::string&amp;)&gt;;

/** Returned by a RESTPathFunc. Stores the actual RESTFunc to execute
    and a boolean indicating if it must be run asynchronously. */
struct PathResponse
{
    RESTFunc func;
    bool async = false;
};

/** HTTP REST callback with path + payload, returning a PathResponse.
    "path" provides the url part after the endpoint, for instance:
    endpoint: "api/windows" | url: "api/windows/567/thumbnail" -&gt;
    path: "567/thumbnail"
*/
using RESTPathFunc = std::function&lt;PathResponse(const std::string&amp;,
                                                const std::string&amp;)&gt;;

class Server
{
public:
    /** ... */

    /** Handle a single action on a given endpoint. */
    void handle(Verb action, const std::string&amp; endpoint, RESTFunc func,
                bool async);

    /** Handle all urls starting with the given endpoint. */
    void handlePath(Verb action, const std::string&amp; endpoint,
                    RESTPathFunc func);

    /** ... */
}
}
}
</pre><h2>Examples</h2>
<p>This example is similar to the one in proposition #1. It explores the handling of path requests in a synchronous or asynchronous manner depending on the url. </p><pre class="fragment">using namespace zeroeq;
http::Server server{ /** ... */ };

// simplified window collection for the example
std::set&lt;std::string&gt; windows{"1234", "567"};

// example path: "", "567/thumbnail", "567/wrongproperty"
const auto getWindowInfo = [&amp;](const std::string&amp; path, const std::string&amp;)
{
    // GET "api/windows" -&gt; list all windows
    if (path.empty())
    {
        const auto func = [&amp;](const std::string&amp;)
        {
            auto response = http::Response;
            response.contentType = "application/json";
            response.payload = toJsonString(windows);
            return response;
        }
        return PathResponse{func, false};
    }

    const auto input = split(path,'/');
    const auto&amp; windowId = input[0];
    const auto&amp; property = input.size() == 2 ? input[1] : std::string();

    if (!windows.count(windowId))
    {
        return PathResponse{[](const std::string&amp;)
                  { return http::Response{http::Code::NOT_FOUND}; }, false};
    }
    if (property == "thumbnail")
    {
        const auto makeThumbnail = [windowId](const std::string&amp;)
        {
            auto response = http::Response{};
            response.contentType = "image/jpeg";
            response.payload = doTheHeavyWork(windowId);
            return response;
        };
        return PathResponse{makeThumbnail, true};
    }
    return PathResponse{[](const std::string&amp;)
            { return http::Response{http::Code::NOT_IMPLEMENTED}; }, false};
}
server.handlePath(http::Verb::GET, "api/windows", getWindowInfo);

// Here we use a generic endpoint for window close operations. "path"
// contains the url part after the endpoint: "api/windows/567" -&gt; "567"
const auto closeWindow = [&amp;](const std::string&amp; path)
{
    if (!windows.count(path))
        return http::Response{http::Code::NOT_FOUND};

    server.remove("api/windows/"+path+"/thumbnail");
    windows.erase(path);
    return http::Response{http::Code::OK};
};
const auto deleteWindow = [&amp;](const std::string&amp; path, const std::string&amp;)
{
    const auto func = [path](const std::string&amp;){ closeWindow(path); };
    return PathResponse{func, false};
};
server.handlePath(http::Verb::DELETE, "api/windows", deleteWindow);

// This function uses POST to open a new window and return its location.
const auto openWindow = [&amp;](const std::string&amp; request)
{
    if (!windows.insert(request))
        return http::Response{http::Code::NO_CONTENT};

    auto response = http::Response();
    response.code = http::Code::CREATED;
    response.headers[http::Header::LOCATION] = "api/windows/"+request;
    return response;
};
server.handle(http::Verb::POST, "api/windows", openWindow, false);
</pre><h2>Implementation</h2>
<pre class="fragment">In requestHandler.h, the struct HTTPRequest needs to be changed from:

    // output from zeroeq::http::Server
    HTTPServer::connection::status_t status;
    std::string reply;

to

    // output from zeroeq::http::Server
    Response response;
    RESTFunc asyncResponse;

In requestHandler.cpp, ConnectionHandler::_handleRequest must do:
if (httpRequest.asyncResponse)
    response = httpRequest.asyncResponse();

In server.cpp, additional maps must be added for the POST, PATCH and DELETE
actions. Each map must also store a boolean indicating whether the function
should be called synchronusly or asynchronously.
Adding support for handlePath() should be straighforward.
</pre><h2>Issues</h2>
<h3>1: How many threads should the cppnetlib server use?</h3>
<p><em>Resolution: Open:</em> The server thread pool consists of a single thread by default. Using more threads may improve performance by accepting multiple concurrent requests but would require changes in the zeroeq inproc signaling mechanism. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Mar 3 2017 11:48:26 for ZeroEQ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
