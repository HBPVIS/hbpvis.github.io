<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>ZeroEQ: Request-Reply</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ZeroEQ
   &#160;<span id="projectnumber">0.9.0</span>
   </div>
   <div id="projectbrief">ZeroEQ - Zero Event Queue</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('reqrep.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Request-Reply </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Certain algorithms need synchronous, RPC-like exchanges. This specification describes a client-server API based on zmq req-rep (dealer/router) sockets.</p>
<h2>Requirements</h2>
<ul>
<li>Asynchronous remote procedure call with later return synchronization from a Client to a Server</li>
</ul>
<h2>API</h2>
<pre class="fragment">using ReplyFunc = std::function&lt;void(const uint128_t&amp;, const void*, size_t)&gt;;

class Client : public Receiver
{
    // ctors same as Subscriber
    /** @return false on send error */
    bool request(const Serializable&amp; request, ReplyFunc&amp; func);
};

using ReplyData = std::pair&lt; uint128_t, servus::Serializable::Data &gt;;
using HandleFunc = std::function&lt;ReplyData(const void*, size_t)&gt;;

class Server : public Receiver
{
    // ctors as Publisher
    void handle(const uint128_t&amp; request, HandleFunc&amp; func)
};
</pre><h2>Implementation</h2>
<ul>
<li>Maps closely to ZeroMQ<ul>
<li>Client uses a dealer socket, receive() will call ReplyFunc</li>
<li>Server::receive() uses a rep socket<ul>
<li>Single-threaded, synchronous for now</li>
<li>Can be extended to async model later</li>
<li>does recv()-&gt;send()</li>
</ul>
</li>
</ul>
</li>
<li>Client::request is fully asynchronous</li>
<li>ReplyFunc will get <code>0, nullptr, 0</code> if server has no handle func</li>
</ul>
<h2>Examples</h2>
<h3>Get-Set of Objects</h3>
<p>Debatable use case: get and set will be served by one of the connected servers. The get and set need to call receive(), potentially serving other pending requests. </p><pre class="fragment">Object object;
server.handle(zeroeq::GET | zeroeq::SET, object ;
while(running)
    server.receive();

ObjectPtr object = client.get&lt;Object&gt;();
object-&gt;setFoo(bar);
client.set(*object);

template&lt;class O&gt; std::unique_ptr&lt;O&gt; Client::get()
{
    std::unique_ptr&lt;O&gt; object;
    request( zeroeq::GetObject( O::ZEROBUF_TYPE_IDENTIFIER()),
        [&amp;]( const uint128_t&amp; type, const void* data, const size_t size ){
            check type match
            object = new O;
            object-&gt;fromBinary(data, size);
        });

    while( !object &amp;&amp; timeout &gt; 0 )
    {
        receive(timeout);
        update timeout;
    }
    return object;
}
</pre><h3>Livre Remote DataSource</h3>
<pre class="fragment">class livre::RemoteDataSource
{
    RemoteDataSource(const DataSourcePluginData&amp; initData)
    {
        _client.request( initData.uri,
            [&amp;]( const uint128_t&amp; type, const void* data, const size_t size ){
                handle mismatch return type
                initData.info = *VolumeInformation::create( data, size );
            });
        _client.receive( TIMEOUT );
    }

    MemoryUnitPtr getData(const LODNode&amp; node)
    {
        MemoryUnitPtr block;
        _client.request({node, _uri},
                    [&amp;]( const uint128_t&amp; type, const void* data, const size_t size ){
                        handle mismatch return type
                        block = new AllocMemoryUnit(size);
                        memcpy data to block
                    });

        _client.receive( TIMEOUT );
        return block;
    }

    zeroeq::Client _client;
};

class livre::RemoteDataService
{
    RemoteDataService(const URI&amp; uri) // does not return
    {
        _server.handle(URI::getTypeIdentifier(), &amp;_getInfo);
        _server.handle(LODNode::getTypeIdentifier(), &amp;_getData);

        while( _server.receive()) /*nop*/ ;
    }

    zeroeq::Server _server;

    ReplyData _getInfo(const void* data, const size_t size)
    {
        ConstURIPtr uri = livre::URI::create(data, size);
        if( openAndCacheDatasource( *uri ))
            return { info.getTypeIdentifier(), info.toBinary() };
        return {};
    }

    ReplyData _getData(const void* data, const size_t size)
    {
        ConstLODNodeURIPtr node = livre::LODNodeURI::create(data, size);
        // open data source if needed, error handling, ...
        const auto&amp; data = dataSource.getData(*node);
        return {data.getTypeIdentifier(), data.toBinary()};
    }
};
</pre><h2>Issues</h2>
<h3>1: Shall the handle function return a future like the <a href="http::Server?">http::Server?</a></h3>
<p><em>Resolution: No:</em> The <a href="http::Server">http::Server</a> manages internal thread(s) for the protocol handling. The zmq rep socket does not, and a multithreaded server would still call handle() synchronously from each worker thread.</p>
<h3>2: Is the client a receiver?</h3>
<p><em>Resolution: Yes:</em> The get method only sends the request, the reply is received in receive() and correlated to the request.</p>
<h3>3: Do we need to type the reply data?</h3>
<p><em>Resolution: Yes:</em> If the return value data is not typed, it requires that the client and server use the same object and version for this, i.e., the hard versioning of ZeroBuf wrt member layout is lost. The ID is not part of the ZeroBuf, so it needs separate transport and checking in server/client. This also allows different return types for a single request.</p>
<h3>4. Should Client::request() return a future?</h3>
<p><em>Resolution: No:</em> This complicates the implementation and contract. It can be layered on top easily.</p>
<p>The proposed API makes the contract explicit: All requests on a client are sent round-robin to all connected servers, and replies arrive in a random order in receive. A future-based API would need to de-multiplex and buffer the incoming requests to the corresponding futures, either from future.get() or .wait() or a separate thread. A user can as well track the outstanding requests, either by the objects sent back or through futures, and still has the full control when this happens. When a common use case <em>and the associated contract</em> becomes clear this can be implemented on top of this API. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="rfcs.html">RFCs</a></li>
    <li class="footer">Generated on Fri Dec 1 2017 01:44:59 for ZeroEQ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
